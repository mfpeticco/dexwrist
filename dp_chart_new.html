<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Animated Bar Chart – DexWrist</title>
<style>
  :root{
    --series-a:#ff7f50; /* Default Wrist */
    --series-b:#87cefa; /* DexWrist (Ours) */
    --axis:#d0d0d0;
    --grid:#2b2b2b;
    --bg:#f5f5f5;
    --text:#2b2b2b;
    --font: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  }
  body{margin:0;background:var(--bg);color:var(--text);font-family:var(--font);}

  /* === Section wrapper you can drop anywhere === */
  .chart-section{
    max-width: 900px;
    margin: 60px auto 0;      /* remove bottom margin */
    padding: 24px 18px 0;     /* remove bottom padding */
  }

  .chart-title{
    margin: 0 0 10px 0;
    font-size: 1.7em;
    font-weight: 650;
    letter-spacing:.2px;
    text-align: center;
  }
  .chart-subtitle{margin:0 0 18px 0;color:#444;font-size:14px;}

  .legend{
    display:flex;
    gap:18px;
    align-items:center;
    justify-content: center;        /* center items horizontally */
    margin:18px auto 18px;             /* center the block itself */
    font-size:1.2em;
  }
  .legend .key{display:inline-flex;align-items:center;gap:8px}
  .legend .swatch{width:14px;height:14px;border-radius:3px;display:inline-block}

  /* === SVG sizing === */
  .chart-wrap{position:relative}
  svg{width:100%;height:420px;display:block}

  /* Bars animate via scaleY to avoid reflow */
  rect.bar{
    transform: scaleY(0);
    transform-origin: bottom;
    transform-box: fill-box;   /* critical for proper origin in SVG */
    transition: transform 1800ms cubic-bezier(.24,.8,.22,1);
  }
  /* Staggered appearance */
  rect.bar[data-delay]{ transition-delay: var(--d, 0ms); }

  /* Triggered when in view */
  svg.in-view rect.bar{ transform: scaleY(1); }

  /* Axis & grid */
  .axis text{ font-size:12px; fill:var(--text) }
  .grid line{ stroke:var(--grid); stroke-width:1; shape-rendering:crispEdges; stroke-dasharray:4 4 }
  .axis line, .axis path{ stroke:var(--axis); stroke-width:1 }

  /* Error bars (optional) */
  .err{ stroke:#333; stroke-width:2 }

  /* Category labels */
  .cat-label{ font-size:1.3em; fill:#222 }

  /* Y axis title */
  .y-title{ font-size:12px; fill:var(--text) }
  .bar-label{ font-size:12px; fill:var(--text) }
  @media (prefers-reduced-motion: reduce){
    rect.bar{ transition-duration:0ms }
  }

  .policy-videos{
    display:flex;
    gap:16px;
    justify-content:center;
    align-items:flex-start;
    margin-top:16px;
  }
  /* New: wrapper per video to enable equal sizing + caption */
  .policy-item{
    flex:1 1 0;
    max-width:48%;
    display:flex;
    flex-direction:column;
    align-items:center;
  }
  .policy-item video{
    width:100%;
    aspect-ratio:16/9;     /* equal height for both */
    object-fit:cover;    /* fill the container, crop if needed */
    border-radius:8px;
    background:#000;
  }
  .policy-caption{
    margin-top:8px;
    font-size:1.2em;
    color:#444;
    text-align:center;
  }
  @media (max-width: 720px){
    .policy-videos{ flex-direction:column; }
    .policy-item{ max-width:100%; }
    .policy-item video{ width:100%; }
  }
</style>
</head>
<body>

<section class="chart-section" id="dexwrist-chart">
  <h2 class="chart-title">Policy Success Rate (%)</h2>
  <!-- <p class="chart-subtitle">Default Wrist vs DexWrist (Ours)</p> -->

  <div class="legend" aria-hidden="false" role="list">
    <span class="key" role="listitem"><i class="swatch" style="background:var(--series-a)"></i> Default Wrist</span>
    <span class="key" role="listitem"><i class="swatch" style="background:var(--series-b)"></i> DexWrist (Ours)</span>
  </div>

  <div class="chart-wrap">
    <svg id="chartSvg" viewBox="0 0 900 420" aria-labelledby="chartTitle chartDesc" role="img">
      <title id="chartTitle">Policy Success Rate</title>
      <desc id="chartDesc">Grouped bar chart comparing Default Wrist and DexWrist across tasks.</desc>
      <!-- content is drawn by JS -->
    </svg>
  </div>

  <!-- Updated: side-by-side equal-size videos with captions -->
  <div class="policy-videos">
    <div class="policy-item">
      <video src="static/videos/FridgePolicyStock.mp4" muted playsinline autoplay loop></video>
      <div class="policy-caption">AgileX + Stock Wrist</div>
    </div>
    <div class="policy-item">
      <video src="static/videos/FridgePolicyWithDexWrist.mp4" muted playsinline autoplay loop></video>
      <div class="policy-caption">AgileX + DexWrist</div>
    </div>
  </div>

  <!-- New: wiping videos (UR3e) -->
  <div class="policy-videos">
    <div class="policy-item">
      <video src="static/videos/WipingStockShort.mp4" muted playsinline autoplay loop></video>
      <div class="policy-caption">UR3e + Stock Wrist</div>
    </div>
    <div class="policy-item">
      <video src="static/videos/WipingDexWristShort.mp4" muted playsinline autoplay loop></video>
      <div class="policy-caption">UR3e + DexWrist</div>
    </div>
  </div>
</section>

<script>
/* ===== 1) DATA – edit these to match your chart =====
   Provide: label, default (series A), dex (series B)
   Optionally: defaultErr, dexErr for error bars (± values)  */
const data = [
  { label: "Whiteboard Erase", default: 28, dex: 68, defaultErr: 8, dexErr: 6 },
  { label: "Cluttered Refrigerator", default: 20, dex: 40, defaultErr: 6, dexErr: 8 }
];

/* ===== 2) CONFIG – tweak visual settings if you like ===== */
const CONFIG = {
  yMax: null,        // null = auto from data; or set (e.g., 80)
  yTicks: 5,         // number of horizontal grid lines
  margins: { top: 28, right: 20, bottom: 100, left: 56 }
};

/* ===== Chart renderer (no dependencies) ===== */
(function renderChart(){
  const svg = document.getElementById('chartSvg');
  const {width: W, height: H} = svg.viewBox.baseVal;
  const M = CONFIG.margins;

  // Compute scales
  const allVals = data.flatMap(d => [d.default, d.dex].filter(v => Number.isFinite(v)));
  const maxVal = Math.max(...allVals, 0);
  const yMax = CONFIG.yMax != null ? CONFIG.yMax : roundUp(maxVal, 10);
  const y = v => H - M.bottom - (v / yMax) * (H - M.top - M.bottom);

  const groups = data.length;
  const isDesktop = W >= 800;
  const innerGap = isDesktop ? 28 : 16;       // space between bars in a group
  const groupGap = isDesktop ? 110 : 60;      // space between groups

  const available = (W - M.left - M.right) - (groups - 1) * groupGap;
  const idealBar = (available / groups - innerGap) / 2;
  const barWidth = clamp(idealBar, isDesktop ? 72 : 52, isDesktop ? 160 : 90);
  const groupWidth = 2*barWidth + innerGap;
  const plotWidth = groups*groupWidth + (groups-1)*groupGap;
  const leftStart = M.left + ( (W - M.left - M.right - plotWidth) / 2 );

  // Clear any prior content
  while (svg.firstChild) svg.removeChild(svg.firstChild);

  // GRID + AXES
  const grid = lineGroup('grid');
  const axis = lineGroup('axis');
  svg.append(grid, axis);

  // Y grid & labels (10-step ticks)
  const step = 10;
  for (let t = 0; t <= yMax; t += step) {
    const yy = y(t);
    grid.appendChild(line(M.left, yy, W - M.right, yy));
    const lbl = text(M.left - 10, yy + 4, t.toFixed(0), 'end');
    lbl.setAttribute('class', 'axis');
    svg.appendChild(lbl);
  }

  // Y-axis line
  axis.appendChild(line(M.left, M.top, M.left, H - M.bottom));
  // X-axis line
  axis.appendChild(line(M.left, H - M.bottom, W - M.right, H - M.bottom));

  // Y axis title
  const yTitle = text(M.left-40, M.top-8, '%', 'start');
  yTitle.setAttribute('class','y-title');
  svg.appendChild(yTitle);

  // Bars
  const barsGroup = group();
  svg.appendChild(barsGroup);

  data.forEach((d, i)=>{
    const gx = leftStart + i*(groupWidth + groupGap);

    // Series A (Default Wrist)
    const aX = gx;
    const aY = y(d.default);
    const aH = (H - M.bottom) - aY;
    const barA = rect(aX, aY, barWidth, aH, 'var(--series-a)');
    barA.classList.add('bar');
    barA.style.setProperty('--d', (100*i) + 'ms');
    barsGroup.appendChild(barA);

    // Series B (DexWrist)
    const bX = gx + barWidth + innerGap;
    const bY = y(d.dex);
    const bH = (H - M.bottom) - bY;
    const barB = rect(bX, bY, barWidth, bH, 'var(--series-b)');
    barB.classList.add('bar');
    barB.style.setProperty('--d', (100*i + 120) + 'ms');
    barsGroup.appendChild(barB);

    // REMOVE per-bar labels:
    // barsGroup.appendChild(barTextLabel(aX + barWidth/2, d.label, "Default Wrist"));
    // barsGroup.appendChild(barTextLabel(bX + barWidth/2, d.label, "DexWrist (Ours)"));

    // ADD one shared group label centered beneath the two bars WITH subtext
    const groupCenter = gx + groupWidth / 2;
    const subLabel = (i === 0) ? 'UR3e' : 'AgileX';
    barsGroup.appendChild(groupTextLabel(groupCenter, d.label, subLabel));
    
    // Error bars (optional)
    if (Number.isFinite(d.defaultErr)){
      barsGroup.appendChild(errorBar(aX, aY, barWidth, y, d.default, d.defaultErr));
    }
    if (Number.isFinite(d.dexErr)){
      barsGroup.appendChild(errorBar(bX, bY, barWidth, y, d.dex, d.dexErr));
    }
  });

  // Helpers
  function group(){ return document.createElementNS('http://www.w3.org/2000/svg','g'); }
  function lineGroup(cls){ const g = group(); g.setAttribute('class', cls); return g; }
  function line(x1,y1,x2,y2){
    const el = document.createElementNS('http://www.w3.org/2000/svg','line');
    el.setAttribute('x1',x1); el.setAttribute('y1',y1);
    el.setAttribute('x2',x2); el.setAttribute('y2',y2);
    return el;
  }
  function rect(x,y,w,h,fill){
    const el = document.createElementNS('http://www.w3.org/2000/svg','rect');
    el.setAttribute('x',x); el.setAttribute('y',y);
    el.setAttribute('width',w); el.setAttribute('height',h);
    el.setAttribute('rx',6); el.setAttribute('ry',6);
    el.setAttribute('fill',fill);
    return el;
  }
  function text(x,y,t,anchor='start'){
    const el = document.createElementNS('http://www.w3.org/2000/svg','text');
    el.setAttribute('x',x); el.setAttribute('y',y);
    el.setAttribute('text-anchor',anchor);
    el.textContent = t;
    return el;
  }
  function errorBar(xBar, yTop, barW, yFn, val, err){
    // Draw a "T" style error bar centered on the bar top with ±err
    const g = group(); g.setAttribute('class','err');
    const centerX = xBar + barW/2;
    const topY = yFn(val + err);
    const botY = yFn(val - err);
    // vertical line
    g.appendChild(line(centerX, topY, centerX, botY));
    // caps
    g.appendChild(line(centerX-10, topY, centerX+10, topY));
    g.appendChild(line(centerX-10, botY, centerX+10, botY));
    return g;
  }
  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  // New: single-line group label centered under each pair
  function groupTextLabel(cx, label, sublabel){
    const ns = "http://www.w3.org/2000/svg";
    const t = document.createElementNS(ns, 'text');
    t.setAttribute('x', cx);
    t.setAttribute('y', H - M.bottom + 26);
    t.setAttribute('text-anchor', 'middle');
    t.setAttribute('class', 'cat-label');

    const t1 = document.createElementNS(ns, 'tspan');
    t1.setAttribute('x', cx);
    t1.setAttribute('dy', 0);
    t1.textContent = label;
    t.appendChild(t1);

    if (sublabel){
      const t2 = document.createElementNS(ns, 'tspan');
      t2.setAttribute('x', cx);
      t2.setAttribute('dy', 24);  // increased from 16 for more space above sublabel
      t2.setAttribute('fill', '#555');
      t2.setAttribute('font-size', '0.9em');
      t2.textContent = sublabel;
      t.appendChild(t2);
    }
    return t;
  }

  // Existing helper (now unused, kept for reference)
  // function barTextLabel(...) { /* ...existing code... */ }

  function roundUp(n, step){
    if (!isFinite(n) || n<=0) return step;
    const s = step || 10;
    return Math.ceil(n/s)*s;
  }
})();

/* ===== Animate when in view ===== */
(function observe(){
  const svg = document.getElementById('chartSvg');
  const go = ()=> svg.classList.add('in-view');

  if ('IntersectionObserver' in window){
    const io = new IntersectionObserver((entries)=>{
      entries.forEach(entry=>{
        if (entry.isIntersecting){
          go();
          io.unobserve(entry.target);
        }
      });
    }, { root:null, rootMargin:"0px", threshold:0.4 });
    io.observe(svg);
  } else {
    // Fallback
    window.addEventListener('load', go);
  }
})();

/* ===== Handle resize (keeps labels crisp on DPR changes) ===== */
window.addEventListener('resize', ()=> {
  // Re-render by simply toggling a reflow on the svg;
  // bars keep their final heights; no re-animation.
  const svg = document.getElementById('chartSvg');
  svg.style.opacity = '0.99';
  requestAnimationFrame(()=> svg.style.opacity = '1');
});

/* Auto-resize messaging to parent */
(function(){
  function computeHeight(){
    // Use the larger of body/html to be robust
    var h = Math.max(
      document.documentElement.scrollHeight,
      document.body ? document.body.scrollHeight : 0
    );
    // As a fallback, include SVG height if needed
    var svg = document.getElementById('chartSvg');
    if (svg) {
      var bboxH = svg.viewBox && svg.viewBox.baseVal ? svg.viewBox.baseVal.height : svg.getBoundingClientRect().height;
      h = Math.max(h, Math.ceil(bboxH) + 80); // add header/legend margin
    }
    return h;
  }

  function postHeight(){
    var h = computeHeight();
    try {
      parent.postMessage({ type: 'dexwrist-chart-height', height: h }, '*');
    } catch(e){}
  }

  window.addEventListener('load', function(){
    // After initial paint and after transitions settle
    requestAnimationFrame(postHeight);
    setTimeout(postHeight, 300);   // catch late layout
    setTimeout(postHeight, 1200);  // after bar animations
  });

  window.addEventListener('resize', function(){
    requestAnimationFrame(postHeight);
  });

  window.addEventListener('message', function(e){
    // Respond to any parent asking for height
    var d = e.data || {};
    if (d.type === 'request-height') postHeight();
  });
})();
</script>
</body>
</html>